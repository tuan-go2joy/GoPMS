import { QueryClient, QueryObserver, QueriesObserver, InfiniteQueryObserver, MutationObserver } from 'react-query/core';
export { InfiniteQueryObserver, MutationCache, MutationObserver, QueriesObserver, QueryCache, QueryClient, QueryObserver, dehydrate, focusManager, hydrate, setLogger } from 'react-query/core';
import { toRefs, reactive, isRef, unref, getCurrentInstance, inject, provide, onUnmounted, isVue2, watch, readonly, isReactive, watchEffect, ref } from 'vue-demi';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var VUE_QUERY_CLIENT = "VUE_QUERY_CLIENT";
function getClientKey(key) {
    var suffix = key ? ":".concat(key) : "";
    return "".concat(VUE_QUERY_CLIENT).concat(suffix);
}
function isQueryKey(value) {
    return typeof value === "string" || Array.isArray(value);
}
function parseQueryArgs(arg1, arg2, arg3) {
    if (arg2 === void 0) { arg2 = {}; }
    if (arg3 === void 0) { arg3 = {}; }
    var options;
    if (!isQueryKey(arg1)) {
        options = arg1;
    }
    else if (typeof arg2 === "function") {
        options = __assign(__assign({}, toRefs(reactive(arg3))), { queryKey: arg1, queryFn: arg2 });
    }
    else {
        options = __assign(__assign({}, toRefs(reactive(arg2))), { queryKey: arg1 });
    }
    return reactive(options);
}
function parseFilterArgs(arg1, arg2) {
    if (isQueryKey(arg1)) {
        return Object.assign(arg2, { queryKey: arg1 });
    }
    return arg1 || {};
}
function parseMutationArgs(arg1, arg2, arg3) {
    if (arg2 === void 0) { arg2 = {}; }
    if (arg3 === void 0) { arg3 = {}; }
    if (isQueryKey(arg1)) {
        if (typeof arg2 === "function") {
            return Object.assign(arg3, {
                mutationKey: arg1,
                mutationFn: arg2,
            });
        }
        return Object.assign(arg2, { mutationKey: arg1 });
    }
    if (typeof arg1 === "function") {
        return Object.assign(arg2, { mutationFn: arg1 });
    }
    return arg1;
}
function parseMutationFilterArgs(arg1, arg2) {
    if (isQueryKey(arg1)) {
        return Object.assign(arg2, {
            mutationKey: arg1,
        });
    }
    return arg1;
}
function updateState(state, update) {
    Object.keys(state).forEach(function (key) {
        state[key] = update[key];
    });
}
function cloneDeep(value, customizer) {
    if (customizer) {
        var result = customizer(value);
        if (result !== undefined) {
            return result;
        }
    }
    if (Array.isArray(value)) {
        return value.map(function (val) { return cloneDeep(val, customizer); });
    }
    if (typeof value === "object" && isPlainObject(value)) {
        var entries = Object.entries(value).map(function (_a) {
            var key = _a[0], val = _a[1];
            return [
                key,
                cloneDeep(val, customizer),
            ];
        });
        return Object.fromEntries(entries);
    }
    return value;
}
function cloneDeepUnref(obj) {
    return cloneDeep(obj, function (val) {
        if (isRef(val)) {
            return cloneDeepUnref(unref(val));
        }
    });
}
function isPlainObject(value) {
    if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
    }
    var prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
}

function useQueryClient(id) {
    var _a;
    if (id === void 0) { id = ""; }
    var vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
    if (!vm) {
        throw new Error("vue-query hooks can only be used inside setup() function.");
    }
    var key = getClientKey(id);
    var queryClient = inject(key);
    if (!queryClient) {
        throw new Error("No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.");
    }
    return queryClient;
}

function useQueryProvider(arg1, id) {
    if (arg1 === void 0) { arg1 = {}; }
    if (id === void 0) { id = ""; }
    var client = arg1 instanceof QueryClient ? arg1 : new QueryClient(arg1);
    client.mount();
    var key = getClientKey(id);
    provide(key, client);
    onUnmounted(function () {
        client.unmount();
    });
}

var VueQueryPlugin = {
    install: function (app, options) {
        var _a;
        if (options === void 0) { options = {}; }
        var clientKey = getClientKey(options.queryClientKey);
        var client;
        if ("queryClient" in options && options.queryClient) {
            client = options.queryClient;
        }
        else {
            var clientConfig = "queryClientConfig" in options ? options.queryClientConfig : undefined;
            client = new QueryClient(clientConfig);
        }
        client.mount();
        var cleanup = function () {
            var _a;
            client.unmount();
            (_a = options.additionalClients) === null || _a === void 0 ? void 0 : _a.forEach(function (additionalClient) {
                additionalClient.queryClient.unmount();
            });
        };
        if (app.onUnmount) {
            app.onUnmount(cleanup);
        }
        else {
            var originalUnmount_1 = app.unmount;
            app.unmount = function vueQueryUnmount() {
                cleanup();
                originalUnmount_1();
            };
        }
        if (isVue2) {
            app.mixin({
                beforeCreate: function () {
                    var _this = this;
                    var _a;
                    if (!this._provided) {
                        var provideCache_1 = {};
                        Object.defineProperty(this, "_provided", {
                            get: function () { return provideCache_1; },
                            set: function (v) { return Object.assign(provideCache_1, v); },
                        });
                    }
                    this._provided[clientKey] = client;
                    (_a = options.additionalClients) === null || _a === void 0 ? void 0 : _a.forEach(function (additionalClient) {
                        var key = getClientKey(additionalClient.queryClientKey);
                        _this._provided[key] = additionalClient.queryClient;
                        additionalClient.queryClient.mount();
                    });
                },
            });
        }
        else {
            app.provide(clientKey, client);
            (_a = options.additionalClients) === null || _a === void 0 ? void 0 : _a.forEach(function (additionalClient) {
                var key = getClientKey(additionalClient.queryClientKey);
                app.provide(key, additionalClient.queryClient);
                additionalClient.queryClient.mount();
            });
        }
    },
};

function useBaseQuery(Observer, arg1, arg2, arg3) {
    if (arg2 === void 0) { arg2 = {}; }
    if (arg3 === void 0) { arg3 = {}; }
    var options = getQueryUnreffedOptions();
    var queryClient = useQueryClient(options.queryClientKey);
    var defaultedOptions = queryClient.defaultQueryObserverOptions(options);
    var observer = new Observer(queryClient, defaultedOptions);
    var state = reactive(observer.getCurrentResult());
    var unsubscribe = observer.subscribe(function (result) {
        updateState(state, result);
    });
    watch([function () { return arg1; }, function () { return arg2; }, function () { return arg3; }], function () {
        observer.setOptions(queryClient.defaultQueryObserverOptions(getQueryUnreffedOptions()));
    }, { deep: true });
    onUnmounted(function () {
        unsubscribe();
    });
    return __assign(__assign({}, toRefs(readonly(state))), { suspense: function () { return observer.fetchOptimistic(defaultedOptions); } });
    function getQueryUnreffedOptions() {
        var options;
        if (!isQueryKey(arg1)) {
            options = arg1;
        }
        else if (typeof arg2 === "function") {
            options = __assign(__assign({}, arg3), { queryKey: arg1, queryFn: arg2 });
        }
        else {
            options = __assign(__assign({}, arg2), { queryKey: arg1 });
        }
        return cloneDeepUnref(options);
    }
}

function useQuery(arg1, arg2, arg3) {
    return useBaseQuery(QueryObserver, arg1, arg2, arg3);
}

function useQueries(queries) {
    var _a;
    var queryClientKey = (_a = unref(queries)[0]) === null || _a === void 0 ? void 0 : _a.queryClientKey;
    var queryClient = useQueryClient(queryClientKey);
    var defaultedQueries = unref(queries).map(function (options) {
        return queryClient.defaultQueryObserverOptions(options);
    });
    var observer = new QueriesObserver(queryClient, defaultedQueries);
    var state = reactive(observer.getCurrentResult());
    var unsubscribe = observer.subscribe(function (result) {
        state.splice.apply(state, __spreadArray([0, state.length], result, false));
    });
    if (isRef(queries) || isReactive(queries)) {
        watch(queries, function () {
            var defaulted = unref(queries).map(function (options) {
                return queryClient.defaultQueryObserverOptions(options);
            });
            observer.setQueries(defaulted);
        });
    }
    onUnmounted(function () {
        unsubscribe();
    });
    return readonly(state);
}

function useInfiniteQuery(arg1, arg2, arg3) {
    return useBaseQuery(InfiniteQueryObserver, arg1, arg2, arg3);
}

function useMutation(arg1, arg2, arg3) {
    var options = parseMutationArgs(arg1, arg2, arg3);
    var queryClient = useQueryClient(options.queryClientKey);
    var observer = new MutationObserver(queryClient, options);
    var state = reactive(observer.getCurrentResult());
    var unsubscribe = observer.subscribe(function () {
        updateState(state, observer.getCurrentResult());
    });
    var mutate = function (variables, mutateOptions) {
        observer.mutate(variables, mutateOptions).catch(function () {
        });
    };
    watchEffect(function () {
        observer.setOptions(options);
    });
    onUnmounted(function () {
        unsubscribe();
    });
    var resultRefs = toRefs(readonly(state));
    return __assign(__assign({}, resultRefs), { mutate: mutate, mutateAsync: state.mutate });
}

function useIsFetching(arg1, arg2) {
    var filters = ref({});
    var parsedFilters = parseFilterArgs(arg1, arg2);
    filters.value = parsedFilters;
    var queryClient = useQueryClient(parsedFilters.queryClientKey);
    var isFetching = ref(queryClient.isFetching(filters.value));
    var unsubscribe = queryClient.getQueryCache().subscribe(function () {
        isFetching.value = queryClient.isFetching(filters.value);
    });
    watchEffect(function () {
        var parsedFiltersUpdate = parseFilterArgs(arg1, arg2);
        filters.value = parsedFiltersUpdate;
    });
    onUnmounted(function () {
        unsubscribe();
    });
    return isFetching;
}

function useIsMutating(arg1, arg2) {
    var filters = parseMutationFilterArgs(arg1, arg2);
    var queryClient = useQueryClient(filters === null || filters === void 0 ? void 0 : filters.queryClientKey);
    var isMutating = ref(queryClient.isMutating(filters));
    var unsubscribe = queryClient.getMutationCache().subscribe(function () {
        isMutating.value = queryClient.isMutating(filters);
    });
    onUnmounted(function () {
        unsubscribe();
    });
    return isMutating;
}

export { VUE_QUERY_CLIENT, VueQueryPlugin, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, useInfiniteQuery, useIsFetching, useIsMutating, useMutation, useQueries, useQuery, useQueryClient, useQueryProvider };
//# sourceMappingURL=index.js.map
